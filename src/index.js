const traversed = new WeakSet();

export default function({ types: t, template }) {
  const buildIsString = template(`typeof V === 'string' || Object.prototype.toString.call(V) === '[object String]'`);
  const buildIsNumber = template(`typeof V === 'number' || Object.prototype.toString.call(V) === '[object Number]'`);
  const buildIsIndex = (() => {
    const tmpl = template(`(ISNUMBER || (ISSTRING && (+V).toString() === V)) && +V === +V`);
    return ({ V }) => {
      return tmpl({
        V,
        ISNUMBER: buildIsNumber({ V }),
        ISSTRING: buildIsString({ V }),
      });
    };
  })();

  const buildStringIndexer = (() => {
    const tmpl = template(`STRING.charAt(INDEX)`);
    return (expr) => {
      return tmpl({
        STRING: expr.object,
        INDEX: t.NumericLiteral(+expr.property.value)
      })
    };
  })();
  const buildStringProperty = (() => {
    const tmpl = template(`ISINDEX ? STRING.charAt(PROPERTY) : MEMBEREXPRESSION`);
    return (expr) => {
      return tmpl({
        STRING: expr.object,
        PROPERTY: expr.property,
        MEMBEREXPRESSION: expr,
        ISINDEX: buildIsIndex({ V: expr.property })
      });
    };
  })();

  const buildIdentfierIndexer = (() => {
    const tmpl = template(`ISSTRINGOBJECT ? OBJECT.charAt(INDEX) : MEMBEREXPRESSION`);
    return (expr) => {
      return tmpl({
        OBJECT: expr.object,
        INDEX: t.NumericLiteral(+expr.property.value),
        MEMBEREXPRESSION: expr,
        ISSTRINGOBJECT: buildIsString({ V: expr.object })
      });
    };
  })();
  const buildIdentifierProperty = (() => {
    const tmpl = template(`ISSTRINGOBJECT && ISINDEXPROPERTY ? STRING.charAt(PROPERTY) : MEMBEREXPRESSION`);
    return (expr) => {
      return tmpl({
        STRING: expr.object,
        PROPERTY: expr.property,
        MEMBEREXPRESSION: expr,
        ISSTRINGOBJECT: buildIsString({ V: expr.object }),
        ISINDEXPROPERTY: buildIsIndex({ V: expr.property })
      });
    };
  })();

  function isIndex(n) {
    return (
      t.isNumericLiteral(n) ||
      (t.isStringLiteral(n) &&
       (+n.value).toString() === n.value &&
       !Number.isNaN(+n.value))
    );
  }

  return {
    visitor: {
      MemberExpression: {
        exit(path) {
          const { node, parent, scope } = path;

          // skip if left value
          if(t.isAssignmentExpression(parent) && node === parent.left) {
            return;
          }

          // skip if dotted notation
          if(!node.computed) {
            return;
          }

          // skip if generated by this plugin
          if(traversed.has(node)) {
            return;
          }
          traversed.add(node);

          const {
            object: o,
            property: p
          } = node;

          let replacement;

          if(t.isStringLiteral(o)) {
            if(isIndex(p)) {
              // "str"[0], "str"["1"], not "str"[''], "str"['02']
              replacement = buildStringIndexer(node);
            } else if(t.isIdentifier(p)) {
              // "s"[a]
              replacement = buildStringProperty(node);
            }
          } else if(t.isIdentifier(o)) {
            if(isIndex(p)) {
              // a[0], a["1"], not a[''], a['02']
              replacement = buildIdentfierIndexer(node);
            } else if(t.isIdentifier(p)) {
              // a[b]
              replacement = buildIdentifierProperty(node);
            }
          }

          if(replacement) {
            path.replaceWith(replacement);
          }
        }
      }
    }
  };
}
